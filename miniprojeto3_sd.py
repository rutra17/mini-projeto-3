# -*- coding: utf-8 -*-
"""Miniprojeto3 SD.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Gyyre600KIqy6r0GFCu3ZPZ1uwbxv5Od

Abaixo está a primeira parte do código para configurar a estrutura básica do sistema de atendimento com tolerância a falhas.

Esta parte do código inclui:

Definição das classes: Atendente para representar os atendentes e Servidor para representar cada servidor no sistema.

Inicialização de um supervisor para monitorar o status dos atendentes e redirecionar solicitações.

Parte 1: Estrutura de Classes e Configuração do Sistema
"""

import random
import threading
import time

# Classe Atendente para representar atendentes de Suporte Técnico e Vendas
class Atendente:
    def __init__(self, id_atendente, tipo):
        self.id = id_atendente
        self.tipo = tipo  # Tipo: "Suporte Técnico" ou "Vendas"
        self.disponivel = True  # Status de disponibilidade

    def atender(self, solicitacao):
        """Processa uma solicitação. Simula o tempo de atendimento."""
        print(f"Atendente {self.id} ({self.tipo}) está atendendo solicitação: {solicitacao}")
        time.sleep(random.uniform(0.5, 1.5))  # Simula o tempo de atendimento
        print(f"Atendente {self.id} ({self.tipo}) concluiu a solicitação: {solicitacao}")
        self.disponivel = True

# Classe Servidor para gerenciar um grupo de atendentes
class Servidor:
    def __init__(self, id_servidor, capacidade):
        self.id = id_servidor
        self.capacidade = capacidade
        self.atendentes = []
        self.solicitacoes = []

    def adicionar_atendente(self, atendente):
        """Adiciona um atendente ao servidor."""
        if len(self.atendentes) < self.capacidade:
            self.atendentes.append(atendente)
        else:
            print(f"Capacidade máxima atingida no Servidor {self.id}")

    def redirecionar_solicitacao(self, solicitacao, tipo):
        """Redireciona uma solicitação para um atendente disponível do tipo correto."""
        atendente_disponivel = next((a for a in self.atendentes if a.tipo == tipo and a.disponivel), None)
        if atendente_disponivel:
            atendente_disponivel.disponivel = False
            thread = threading.Thread(target=atendente_disponivel.atender, args=(solicitacao,))
            thread.start()
        else:
            print(f"Solicitação {solicitacao} foi colocada na fila no Servidor {self.id}")
            self.solicitacoes.append((solicitacao, tipo))

# Classe Supervisor para monitorar os servidores e redirecionar solicitações em caso de falha
class Supervisor:
    def __init__(self, servidores):
        self.servidores = servidores

    def monitorar(self):
        """Verifica status dos servidores e redireciona solicitações em caso de falha."""
        while True:
            for servidor in self.servidores:
                for solicitacao, tipo in list(servidor.solicitacoes):
                    atendente_disponivel = next((a for a in servidor.atendentes if a.tipo == tipo and a.disponivel), None)
                    if atendente_disponivel:
                        servidor.solicitacoes.remove((solicitacao, tipo))
                        servidor.redirecionar_solicitacao(solicitacao, tipo)
            time.sleep(1)  # Monitoramento periódico

# Função para configurar o sistema inicial
def configurar_sistema():
    # Configuração de atendentes e servidores
    servidor_a = Servidor("A", capacidade=5)
    servidor_b = Servidor("B", capacidade=7)
    servidores = [servidor_a, servidor_b]

    # Adicionar atendentes aos servidores
    for i in range(3):
        servidor_a.adicionar_atendente(Atendente(f"A{i}", "Suporte Técnico"))
        servidor_a.adicionar_atendente(Atendente(f"A{i+3}", "Vendas"))

    for i in range(4):
        servidor_b.adicionar_atendente(Atendente(f"B{i}", "Suporte Técnico"))
        servidor_b.adicionar_atendente(Atendente(f"B{i+4}", "Vendas"))

    # Criar e iniciar o supervisor
    supervisor = Supervisor(servidores)
    threading.Thread(target=supervisor.monitorar, daemon=True).start()

    return servidores

# Inicialização do sistema
servidores = configurar_sistema()

# Simulação de solicitações
def simular_solicitacoes():
    tipos_solicitacoes = ["Suporte Técnico", "Vendas"]
    for i in range(10):
        tipo = random.choice(tipos_solicitacoes)
        servidor = random.choice(servidores)
        servidor.redirecionar_solicitacao(f"Solicitação {i}", tipo)
        time.sleep(0.5)  # Intervalo entre solicitações

# Iniciar a simulação de solicitações
simular_solicitacoes()

"""Agora vamos adicionar a simulação de falhas para que os atendentes possam falhar aleatoriamente, e o sistema consiga redirecionar as solicitações para atendentes ativos. Além disso, vamos aprimorar o monitoramento do supervisor para lidar com as falhas e ajustar o sistema dinamicamente.

Parte 2: Simulação de Falhas e Redirecionamento
Para simular as falhas, faremos o seguinte:

Adicionar probabilidade de falha aos atendentes, que poderão falhar em qualquer momento durante a execução.
Redirecionamento automático pelo supervisor para atender as solicitações dos atendentes falhos.
"""

# Importando bibliotecas necessárias
import random
import threading
import time

# Classe Atendente para representar atendentes de Suporte Técnico e Vendas
class Atendente:
    def __init__(self, id_atendente, tipo):
        self.id = id_atendente
        self.tipo = tipo  # Tipo: "Suporte Técnico" ou "Vendas"
        self.disponivel = True  # Status de disponibilidade
        self.ativo = True  # Status de atividade (pode falhar)

    def atender(self, solicitacao):
        """Processa uma solicitação, simulando o tempo de atendimento."""
        if not self.ativo:
            print(f"Atendente {self.id} ({self.tipo}) está inativo e não pode atender.")
            return

        print(f"Atendente {self.id} ({self.tipo}) está atendendo solicitação: {solicitacao}")
        time.sleep(random.uniform(0.5, 1.5))  # Simula o tempo de atendimento
        self.disponivel = True
        print(f"Atendente {self.id} ({self.tipo}) concluiu a solicitação: {solicitacao}")

    def simular_falha(self):
        """Simula falha com uma probabilidade definida."""
        if random.random() < 0.2:  # 20% de chance de falha a cada verificação
            self.ativo = False
            print(f"Atendente {self.id} ({self.tipo}) falhou!")

    def recuperar(self):
        """Recupera o atendente após uma falha."""
        self.ativo = True
        print(f"Atendente {self.id} ({self.tipo}) foi recuperado e está ativo novamente.")

# Classe Servidor para gerenciar um grupo de atendentes
class Servidor:
    def __init__(self, id_servidor, capacidade):
        self.id = id_servidor
        self.capacidade = capacidade
        self.atendentes = []
        self.solicitacoes = []

    def adicionar_atendente(self, atendente):
        """Adiciona um atendente ao servidor."""
        if len(self.atendentes) < self.capacidade:
            self.atendentes.append(atendente)
        else:
            print(f"Capacidade máxima atingida no Servidor {self.id}")

    def redirecionar_solicitacao(self, solicitacao, tipo):
        """Redireciona uma solicitação para um atendente disponível e ativo do tipo correto."""
        atendente_disponivel = next((a for a in self.atendentes if a.tipo == tipo and a.disponivel and a.ativo), None)
        if atendente_disponivel:
            atendente_disponivel.disponivel = False
            thread = threading.Thread(target=atendente_disponivel.atender, args=(solicitacao,))
            thread.start()
        else:
            print(f"Solicitação {solicitacao} foi colocada na fila no Servidor {self.id}")
            self.solicitacoes.append((solicitacao, tipo))

    def simular_falhas(self):
        """Simula falhas aleatórias para os atendentes deste servidor."""
        for atendente in self.atendentes:
            atendente.simular_falha()

    def recuperar_atendentes(self):
        """Recupera atendentes falhos de forma aleatória."""
        for atendente in self.atendentes:
            if not atendente.ativo:
                if random.random() < 0.5:  # 50% de chance de recuperação
                    atendente.recuperar()

# Classe Supervisor para monitorar os servidores e redirecionar solicitações em caso de falha
class Supervisor:
    def __init__(self, servidores):
        self.servidores = servidores

    def monitorar(self):
        """Verifica status dos servidores, simula falhas e redireciona solicitações em caso de falha."""
        while True:
            for servidor in self.servidores:
                servidor.simular_falhas()

                # Verificar fila de solicitações e redirecionar se possível
                for solicitacao, tipo in list(servidor.solicitacoes):
                    atendente_disponivel = next((a for a in servidor.atendentes if a.tipo == tipo and a.disponivel and a.ativo), None)
                    if atendente_disponivel:
                        servidor.solicitacoes.remove((solicitacao, tipo))
                        servidor.redirecionar_solicitacao(solicitacao, tipo)

                # Tentativa de recuperação de atendentes falhos
                servidor.recuperar_atendentes()

            time.sleep(2)  # Monitoramento periódico

# Função para configurar o sistema inicial
def configurar_sistema():
    # Configuração de atendentes e servidores
    servidor_a = Servidor("A", capacidade=5)
    servidor_b = Servidor("B", capacidade=7)
    servidores = [servidor_a, servidor_b]

    # Adicionar atendentes aos servidores
    for i in range(3):
        servidor_a.adicionar_atendente(Atendente(f"A{i}", "Suporte Técnico"))
        servidor_a.adicionar_atendente(Atendente(f"A{i+3}", "Vendas"))

    for i in range(4):
        servidor_b.adicionar_atendente(Atendente(f"B{i}", "Suporte Técnico"))
        servidor_b.adicionar_atendente(Atendente(f"B{i+4}", "Vendas"))

    # Criar e iniciar o supervisor
    supervisor = Supervisor(servidores)
    threading.Thread(target=supervisor.monitorar, daemon=True).start()

    return servidores

# Inicialização do sistema
servidores = configurar_sistema()

# Simulação de solicitações
def simular_solicitacoes():
    tipos_solicitacoes = ["Suporte Técnico", "Vendas"]
    for i in range(10):
        tipo = random.choice(tipos_solicitacoes)
        servidor = random.choice(servidores)
        servidor.redirecionar_solicitacao(f"Solicitação {i}", tipo)
        time.sleep(0.5)  # Intervalo entre solicitações

# Iniciar a simulação de solicitações
simular_solicitacoes()

"""Agora vamos implementar a parte de logs e relatórios para registrar a atividade do sistema, incluindo falhas, recuperação de atendentes e redirecionamento de solicitações. Esse registro nos ajudará a entender como o sistema responde a diferentes cenários.

Para isso, faremos o seguinte:

Log de eventos: registra todas as operações importantes (solicitações atendidas, falhas, recuperações e redirecionamentos).
Relatórios periódicos: apresenta o status dos servidores e a quantidade de solicitações atendidas e redirecionadas.

Parte 3: Logs e Relatórios
"""

import random
import threading
import time
from datetime import datetime

# Função de log para registrar eventos do sistema
def log_evento(mensagem):
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    print(f"[{timestamp}] {mensagem}")

# Classe Atendente para representar atendentes de Suporte Técnico e Vendas
class Atendente:
    def __init__(self, id_atendente, tipo):
        self.id = id_atendente
        self.tipo = tipo
        self.disponivel = True
        self.ativo = True  # Status de atividade (pode falhar)

    def atender(self, solicitacao):
        if not self.ativo:
            log_evento(f"Atendente {self.id} ({self.tipo}) está inativo e não pode atender.")
            return

        log_evento(f"Atendente {self.id} ({self.tipo}) começou a atender a solicitação: {solicitacao}")
        time.sleep(random.uniform(0.5, 1.5))
        self.disponivel = True
        log_evento(f"Atendente {self.id} ({self.tipo}) concluiu a solicitação: {solicitacao}")

    def simular_falha(self):
        if random.random() < 0.2:  # 20% de chance de falha
            self.ativo = False
            log_evento(f"Atendente {self.id} ({self.tipo}) falhou!")

    def recuperar(self):
        self.ativo = True
        log_evento(f"Atendente {self.id} ({self.tipo}) foi recuperado e está ativo novamente.")

# Classe Servidor para gerenciar um grupo de atendentes
class Servidor:
    def __init__(self, id_servidor, capacidade):
        self.id = id_servidor
        self.capacidade = capacidade
        self.atendentes = []
        self.solicitacoes = []

    def adicionar_atendente(self, atendente):
        if len(self.atendentes) < self.capacidade:
            self.atendentes.append(atendente)
        else:
            log_evento(f"Capacidade máxima atingida no Servidor {self.id}")

    def redirecionar_solicitacao(self, solicitacao, tipo):
        atendente_disponivel = next((a for a in self.atendentes if a.tipo == tipo and a.disponivel and a.ativo), None)
        if atendente_disponivel:
            atendente_disponivel.disponivel = False
            thread = threading.Thread(target=atendente_disponivel.atender, args=(solicitacao,))
            thread.start()
        else:
            log_evento(f"Solicitação {solicitacao} foi colocada na fila no Servidor {self.id}")
            self.solicitacoes.append((solicitacao, tipo))

    def simular_falhas(self):
        for atendente in self.atendentes:
            atendente.simular_falha()

    def recuperar_atendentes(self):
        for atendente in self.atendentes:
            if not atendente.ativo:
                if random.random() < 0.5:
                    atendente.recuperar()

# Classe Supervisor para monitorar os servidores e redirecionar solicitações em caso de falha
class Supervisor:
    def __init__(self, servidores):
        self.servidores = servidores
        self.logs = []  # Armazenamento de logs para relatórios

    def monitorar(self):
        while True:
            for servidor in self.servidores:
                servidor.simular_falhas()

                # Verificar fila de solicitações e redirecionar se possível
                for solicitacao, tipo in list(servidor.solicitacoes):
                    atendente_disponivel = next((a for a in servidor.atendentes if a.tipo == tipo and a.disponivel and a.ativo), None)
                    if atendente_disponivel:
                        servidor.solicitacoes.remove((solicitacao, tipo))
                        servidor.redirecionar_solicitacao(solicitacao, tipo)

                # Tentativa de recuperação de atendentes falhos
                servidor.recuperar_atendentes()

            time.sleep(2)  # Monitoramento periódico
            self.gerar_relatorio()

    def gerar_relatorio(self):
        log_evento("Gerando relatório de status...")
        for servidor in self.servidores:
            num_atendentes_ativos = sum(atendente.ativo for atendente in servidor.atendentes)
            num_solicitacoes_pendentes = len(servidor.solicitacoes)
            log_evento(f"Servidor {servidor.id}: {num_atendentes_ativos} atendentes ativos, "
                       f"{num_solicitacoes_pendentes} solicitações pendentes.")
        log_evento("Relatório gerado.\n")

# Função para configurar o sistema inicial
def configurar_sistema():
    servidor_a = Servidor("A", capacidade=5)
    servidor_b = Servidor("B", capacidade=7)
    servidores = [servidor_a, servidor_b]

    for i in range(3):
        servidor_a.adicionar_atendente(Atendente(f"A{i}", "Suporte Técnico"))
        servidor_a.adicionar_atendente(Atendente(f"A{i+3}", "Vendas"))

    for i in range(4):
        servidor_b.adicionar_atendente(Atendente(f"B{i}", "Suporte Técnico"))
        servidor_b.adicionar_atendente(Atendente(f"B{i+4}", "Vendas"))

    supervisor = Supervisor(servidores)
    threading.Thread(target=supervisor.monitorar, daemon=True).start()

    return servidores

# Inicialização do sistema
servidores = configurar_sistema()

# Simulação de solicitações
def simular_solicitacoes():
    tipos_solicitacoes = ["Suporte Técnico", "Vendas"]
    for i in range(10):
        tipo = random.choice(tipos_solicitacoes)
        servidor = random.choice(servidores)
        servidor.redirecionar_solicitacao(f"Solicitação {i}", tipo)
        time.sleep(0.5)  # Intervalo entre solicitações

# Iniciar a simulação de solicitações
simular_solicitacoes()

import random
import threading
import time
from datetime import datetime
import pandas as pd
import matplotlib.pyplot as plt
from IPython.display import display, clear_output

# Função de log para registrar eventos do sistema
def log_evento(mensagem):
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    print(f"[{timestamp}] {mensagem}")

# Classe Atendente para representar atendentes
class Atendente:
    def __init__(self, id_atendente, tipo):
        self.id = id_atendente
        self.tipo = tipo
        self.disponivel = True
        self.ativo = True

    def atender(self, solicitacao):
        if not self.ativo:
            log_evento(f"Atendente {self.id} ({self.tipo}) está inativo e não pode atender.")
            return

        log_evento(f"Atendente {self.id} ({self.tipo}) começou a atender a solicitação: {solicitacao}")
        time.sleep(random.uniform(0.5, 1.5))
        self.disponivel = True
        log_evento(f"Atendente {self.id} ({self.tipo}) concluiu a solicitação: {solicitacao}")

    def simular_falha(self):
        if random.random() < 0.2:  # 20% de chance de falha
            self.ativo = False
            log_evento(f"Atendente {self.id} ({self.tipo}) falhou!")

    def recuperar(self):
        if not self.ativo and random.random() < 0.5:  # 50% de chance de recuperação
            self.ativo = True
            log_evento(f"Atendente {self.id} ({self.tipo}) foi recuperado e está ativo novamente.")

# Classe Servidor para gerenciar atendentes
class Servidor:
    def __init__(self, id_servidor, capacidade):
        self.id = id_servidor
        self.capacidade = capacidade
        self.atendentes = []
        self.solicitacoes = []
        self.atendimentos = 0
        self.falhas = 0

    def adicionar_atendente(self, atendente):
        if len(self.atendentes) < self.capacidade:
            self.atendentes.append(atendente)

    def redirecionar_solicitacao(self, solicitacao, tipo):
        atendente_disponivel = next((a for a in self.atendentes if a.tipo == tipo and a.disponivel and a.ativo), None)
        if atendente_disponivel:
            atendente_disponivel.disponivel = False
            thread = threading.Thread(target=atendente_disponivel.atender, args=(solicitacao,))
            thread.start()
            self.atendimentos += 1
        else:
            self.solicitacoes.append((solicitacao, tipo))

    def simular_falhas(self):
        for atendente in self.atendentes:
            if atendente.ativo:
                atendente.simular_falha()
                if not atendente.ativo:
                    self.falhas += 1

    def recuperar_atendentes(self):
        for atendente in self.atendentes:
            atendente.recuperar()

# Supervisor para monitoramento e relatórios
class Supervisor:
    def __init__(self, servidores):
        self.servidores = servidores
        self.redirecionamentos = 0
        self.historico_status = []
        self.historico_transferencias = []

    def monitorar(self):
        timestep = 0
        while True:
            log_evento(f"Timestep {timestep}: Iniciando monitoramento...")
            for servidor in self.servidores:
                servidor.simular_falhas()
                servidor.recuperar_atendentes()

                for solicitacao, tipo in list(servidor.solicitacoes):
                    atendente_disponivel = next((a for a in servidor.atendentes if a.tipo == tipo and a.disponivel and a.ativo), None)
                    if atendente_disponivel:
                        servidor.solicitacoes.remove((solicitacao, tipo))
                        servidor.redirecionar_solicitacao(solicitacao, tipo)
                        self.redirecionamentos += 1

            self.registrar_status(timestep)
            self.gerar_tabelas_e_graficos()
            time.sleep(5)  # Simula o tempo entre timesteps
            timestep += 1

    def registrar_status(self, timestep):
        for servidor in self.servidores:
            self.historico_status.append({
                "Timestep": timestep,
                "Servidor": servidor.id,
                "Atendimentos": servidor.atendimentos,
                "Capacidade": servidor.capacidade,
                "Falhas Detectadas": servidor.falhas,
                "Solicitações Pendentes": len(servidor.solicitacoes)
            })
        self.historico_transferencias.append({
            "Timestep": timestep,
            "Redirecionamentos": self.redirecionamentos
        })

    def gerar_tabelas_e_graficos(self):
        clear_output(wait=True)

        # Criar tabelas
        df_status = pd.DataFrame(self.historico_status)
        df_transferencias = pd.DataFrame(self.historico_transferencias)

        display(df_status, df_transferencias)

        # Gerar gráficos
        if not df_status.empty:
            # Gráfico de Barras - Atendimentos por Servidor
            plt.figure(figsize=(8, 4))
            atendimentos_por_servidor = df_status.groupby("Servidor")["Atendimentos"].max()
            atendimentos_por_servidor.plot(kind="bar", color="blue", title="Atendimentos por Servidor")
            plt.xlabel("Servidor")
            plt.ylabel("Atendimentos")
            plt.tight_layout()
            plt.show()

            # Gráfico de Linha - Falhas ao longo do tempo
            plt.figure(figsize=(8, 4))
            falhas_por_timestep = df_status.groupby("Timestep")["Falhas Detectadas"].sum()
            falhas_por_timestep.plot(kind="line", marker="o", color="red", title="Falhas ao Longo do Tempo")
            plt.xlabel("Timestep")
            plt.ylabel("Falhas Detectadas")
            plt.tight_layout()
            plt.show()

            # Gráfico de Pizza - Distribuição de Redirecionamentos
            plt.figure(figsize=(6, 6))
            total_redirecionamentos = df_transferencias["Redirecionamentos"].sum()
            if total_redirecionamentos > 0:
                plt.pie(
                    [total_redirecionamentos],
                    labels=["Redirecionamentos"],
                    autopct="%1.1f%%",
                    startangle=90,
                    colors=["orange"]
                )
                plt.title("Distribuição de Redirecionamentos")
                plt.tight_layout()
                plt.show()

# Configuração do sistema
def configurar_sistema():
    servidor_a = Servidor("A", capacidade=5)
    servidor_b = Servidor("B", capacidade=7)
    servidores = [servidor_a, servidor_b]

    for i in range(3):
        servidor_a.adicionar_atendente(Atendente(f"A{i}", "Suporte Técnico"))
        servidor_a.adicionar_atendente(Atendente(f"A{i+3}", "Vendas"))

    for i in range(4):
        servidor_b.adicionar_atendente(Atendente(f"B{i}", "Suporte Técnico"))
        servidor_b.adicionar_atendente(Atendente(f"B{i+4}", "Vendas"))

    supervisor = Supervisor(servidores)
    threading.Thread(target=supervisor.monitorar, daemon=True).start()

    return servidores

# Inicialização do sistema
servidores = configurar_sistema()

import matplotlib.pyplot as plt
import pandas as pd
from IPython.display import display, clear_output

# Dados de exemplo para testar os gráficos
dados_status = [
    {"Timestep": 0, "Servidor": "A", "Atendimentos": 5, "Capacidade": 10, "Falhas Detectadas": 2, "Solicitações Pendentes": 3},
    {"Timestep": 1, "Servidor": "A", "Atendimentos": 8, "Capacidade": 10, "Falhas Detectadas": 1, "Solicitações Pendentes": 2},
    {"Timestep": 0, "Servidor": "B", "Atendimentos": 3, "Capacidade": 7, "Falhas Detectadas": 3, "Solicitações Pendentes": 1},
    {"Timestep": 1, "Servidor": "B", "Atendimentos": 6, "Capacidade": 7, "Falhas Detectadas": 0, "Solicitações Pendentes": 1},
]
dados_transferencias = [
    {"Timestep": 0, "Redirecionamentos": 2},
    {"Timestep": 1, "Redirecionamentos": 5},
]

df_status = pd.DataFrame(dados_status)
df_transferencias = pd.DataFrame(dados_transferencias)

# Garantir que o output anterior seja limpo no Colab
clear_output(wait=True)

# Mostrar tabelas
display(df_status, df_transferencias)

# Gráfico de Barras - Atendimentos por Servidor
plt.figure(figsize=(8, 4))
atendimentos_por_servidor = df_status.groupby("Servidor")["Atendimentos"].sum()
atendimentos_por_servidor.plot(kind="bar", color="blue", title="Atendimentos por Servidor")
plt.xlabel("Servidor")
plt.ylabel("Atendimentos")
plt.tight_layout()
plt.show()

# Gráfico de Linha - Falhas ao longo do tempo
plt.figure(figsize=(8, 4))
falhas_por_timestep = df_status.groupby("Timestep")["Falhas Detectadas"].sum()
falhas_por_timestep.plot(kind="line", marker="o", color="red", title="Falhas ao Longo do Tempo")
plt.xlabel("Timestep")
plt.ylabel("Falhas Detectadas")
plt.tight_layout()
plt.show()

# Gráfico de Pizza - Distribuição de redirecionamentos
plt.figure(figsize=(6, 6))
total_redirecionamentos = df_transferencias["Redirecionamentos"].sum()
outros = 10  # Valor fixo para representar "Outros" em relação aos redirecionamentos
plt.pie(
    [total_redirecionamentos, outros],
    labels=["Redirecionamentos", "Outros"],
    autopct="%1.1f%%",
    startangle=90,
    colors=["orange", "lightgrey"]
)
plt.title("Distribuição de Redirecionamentos")
plt.tight_layout()
plt.show()

import random
import threading
import time
from datetime import datetime
import pandas as pd
from IPython.display import display, clear_output

# Função de log
def log_evento(mensagem):
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    print(f"[{timestamp}] {mensagem}")

# Classes e configurações (Atendente, Servidor e Supervisor) - Sem mudanças
class Atendente:
    def __init__(self, id_atendente, tipo):
        self.id = id_atendente
        self.tipo = tipo
        self.disponivel = True
        self.ativo = True

    def atender(self, solicitacao):
        if not self.ativo:
            log_evento(f"Atendente {self.id} ({self.tipo}) está inativo e não pode atender.")
            return
        log_evento(f"Atendente {self.id} ({self.tipo}) começou a atender a solicitação: {solicitacao}")
        time.sleep(random.uniform(0.5, 1.5))
        self.disponivel = True
        log_evento(f"Atendente {self.id} ({self.tipo}) concluiu a solicitação: {solicitacao}")

    def simular_falha(self):
        if random.random() < 0.2:
            self.ativo = False
            log_evento(f"Atendente {self.id} ({self.tipo}) falhou!")

    def recuperar(self):
        if not self.ativo and random.random() < 0.5:
            self.ativo = True
            log_evento(f"Atendente {self.id} ({self.tipo}) foi recuperado.")

class Servidor:
    def __init__(self, id_servidor, capacidade):
        self.id = id_servidor
        self.capacidade = capacidade
        self.atendentes = []
        self.solicitacoes = []
        self.atendimentos = 0
        self.falhas = 0

    def adicionar_atendente(self, atendente):
        if len(self.atendentes) < self.capacidade:
            self.atendentes.append(atendente)

    def redirecionar_solicitacao(self, solicitacao, tipo):
        atendente_disponivel = next((a for a in self.atendentes if a.tipo == tipo and a.disponivel and a.ativo), None)
        if atendente_disponivel:
            atendente_disponivel.disponivel = False
            thread = threading.Thread(target=atendente_disponivel.atender, args=(solicitacao,))
            thread.start()
            self.atendimentos += 1
        else:
            self.solicitacoes.append((solicitacao, tipo))

    def simular_falhas(self):
        for atendente in self.atendentes:
            if atendente.ativo:
                atendente.simular_falha()
                if not atendente.ativo:
                    self.falhas += 1

    def recuperar_atendentes(self):
        for atendente in self.atendentes:
            atendente.recuperar()

class Supervisor:
    def __init__(self, servidores):
        self.servidores = servidores
        self.redirecionamentos = 0
        self.historico_status = []
        self.historico_transferencias = []

    def monitorar(self):
        timestep = 0
        while True:
            log_evento(f"Timestep {timestep}: Iniciando monitoramento...")
            for servidor in self.servidores:
                servidor.simular_falhas()
                servidor.recuperar_atendentes()

                for solicitacao, tipo in list(servidor.solicitacoes):
                    atendente_disponivel = next((a for a in servidor.atendentes if a.tipo == tipo and a.disponivel and a.ativo), None)
                    if atendente_disponivel:
                        servidor.solicitacoes.remove((solicitacao, tipo))
                        servidor.redirecionar_solicitacao(solicitacao, tipo)
                        self.redirecionamentos += 1

            self.registrar_status(timestep)
            self.gerar_tabelas()
            time.sleep(5)  # Simula o tempo entre timesteps
            timestep += 1

    def registrar_status(self, timestep):
        for servidor in self.servidores:
            self.historico_status.append({
                "Timestep": timestep,
                "Servidor": servidor.id,
                "Atendimentos": servidor.atendimentos,
                "Capacidade": servidor.capacidade,
                "Falhas Detectadas": servidor.falhas,
                "Solicitações Pendentes": len(servidor.solicitacoes)
            })
        self.historico_transferencias.append({
            "Timestep": timestep,
            "Redirecionamentos": self.redirecionamentos
        })

    def gerar_tabelas(self):
        clear_output(wait=True)
        df_status = pd.DataFrame(self.historico_status)
        df_transferencias = pd.DataFrame(self.historico_transferencias)

        display(df_status, df_transferencias)

        # Salvar os dados em arquivos CSV
        df_status.to_csv("historico_status.csv", index=False)
        df_transferencias.to_csv("historico_transferencias.csv", index=False)

# Configuração do sistema
def configurar_sistema():
    servidor_a = Servidor("A", capacidade=5)
    servidor_b = Servidor("B", capacidade=7)
    servidores = [servidor_a, servidor_b]

    for i in range(3):
        servidor_a.adicionar_atendente(Atendente(f"A{i}", "Suporte Técnico"))
        servidor_a.adicionar_atendente(Atendente(f"A{i+3}", "Vendas"))

    for i in range(4):
        servidor_b.adicionar_atendente(Atendente(f"B{i}", "Suporte Técnico"))
        servidor_b.adicionar_atendente(Atendente(f"B{i+4}", "Vendas"))

    supervisor = Supervisor(servidores)
    threading.Thread(target=supervisor.monitorar, daemon=True).start()

    return servidores

# Inicialização do sistema
servidores = configurar_sistema()

import matplotlib.pyplot as plt

# Gráfico de Linha - Falhas ao longo do tempo
plt.figure(figsize=(8, 5))
falhas_por_timestep = df_status.groupby("Timestep")["Falhas Detectadas"].sum()

falhas_por_timestep.plot(
    kind="line",
    marker="o",
    color="red",
    title="Falhas ao Longo do Tempo"
)

plt.xlabel("Timestep")
plt.ylabel("Falhas Detectadas")
plt.tight_layout()
plt.show()

# Gráfico de Pizza - Distribuição de Falhas Detectadas por Servidor
plt.figure(figsize=(6, 6))
falhas_por_servidor = df_status.groupby("Servidor")["Falhas Detectadas"].sum()

if falhas_por_servidor.sum() > 0:
    plt.pie(
        falhas_por_servidor,
        labels=falhas_por_servidor.index,
        autopct="%1.1f%%",
        startangle=90,
        colors=plt.cm.Paired.colors
    )
    plt.title("Distribuição de Falhas Detectadas por Servidor")
else:
    plt.text(0.5, 0.5, "Nenhum dado para exibir", ha="center", va="center", fontsize=12)

plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

# Verificando se há dados disponíveis
atendimentos_por_servidor = df_status.groupby("Servidor")["Atendimentos"].sum()

# Criando o gráfico de barras
plt.figure(figsize=(8, 5))

# Certificar que há dados para exibir
if not atendimentos_por_servidor.empty and atendimentos_por_servidor.sum() > 0:
    atendimentos_por_servidor.plot(
        kind="bar",
        color="skyblue",
        edgecolor="black"
    )
    plt.title("Atendimentos por Servidor")
    plt.xlabel("Servidor")
    plt.ylabel("Total de Atendimentos")
    plt.xticks(rotation=0)  # Rotaciona os rótulos no eixo X, se necessário
else:
    plt.text(0.5, 0.5, "Nenhum dado para exibir", ha="center", va="center", fontsize=12)

plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import pandas as pd

# Exemplo de DataFrame com os dados fornecidos
data = {
    'Timestep': [0, 0, 1, 1, 2],
    'Servidor': ['A', 'B', 'A', 'B', 'A'],
    'Atendimentos': [0, 0, 0, 0, 0],
    'Capacidade': [5, 7, 5, 7, 5],
    'Falhas Detectadas': [0, 1, 0, 2, 3],
    'Solicitações Pendentes': [0, 0, 0, 0, 0]
}

# Criando o DataFrame
df_status = pd.DataFrame(data)

# Substituindo os valores de atendimentos para testar a exibição do gráfico
df_status.loc[df_status['Servidor'] == 'A', 'Atendimentos'] = 10
df_status.loc[df_status['Servidor'] == 'B', 'Atendimentos'] = 15

# Agrupando os dados para obter a soma dos atendimentos por servidor
atendimentos_por_servidor = df_status.groupby("Servidor")["Atendimentos"].sum()

# Criando o gráfico de barras
plt.figure(figsize=(8, 5))

# Verificando se os dados estão corretos
if not atendimentos_por_servidor.empty and atendimentos_por_servidor.sum() > 0:
    atendimentos_por_servidor.plot(
        kind="bar",
        color="skyblue",
        edgecolor="black"
    )
    plt.title("Atendimentos por Servidor")
    plt.xlabel("Servidor")
    plt.ylabel("Total de Atendimentos")
    plt.xticks(rotation=0)
else:
    print("Nenhum dado para exibir no gráfico de barras.")
    plt.text(0.5, 0.5, "Nenhum dado para exibir", ha="center", va="center", fontsize=12)

plt.tight_layout()
plt.show()